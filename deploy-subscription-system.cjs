const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

// Configuration
const FUNCTIONS_DIR = './supabase/functions';
const NEW_FUNCTIONS = [
  'smart-pack-change',
  'calculate-pack-difference', 
  'process-immediate-change',
  'handle-subscription-change',
  'cancel-subscription'
];

const REQUIRED_TABLES_SQL = `
-- Table user_credits pour g√©rer les cr√©dits utilisateur
CREATE TABLE IF NOT EXISTS user_credits (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  amount INTEGER NOT NULL,
  type VARCHAR(50) NOT NULL,
  description TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  expires_at TIMESTAMP WITH TIME ZONE,
  used_at TIMESTAMP WITH TIME ZONE,
  metadata JSONB DEFAULT '{}'
);

CREATE INDEX IF NOT EXISTS idx_user_credits_user_id ON user_credits(user_id);
CREATE INDEX IF NOT EXISTS idx_user_credits_type ON user_credits(type);
CREATE INDEX IF NOT EXISTS idx_user_credits_expires_at ON user_credits(expires_at);

-- Table cancellation_feedback pour les retours d'annulation
CREATE TABLE IF NOT EXISTS cancellation_feedback (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  pack_id UUID REFERENCES packs(id),
  reason VARCHAR(100),
  feedback TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  metadata JSONB DEFAULT '{}'
);

CREATE INDEX IF NOT EXISTS idx_cancellation_feedback_user_id ON cancellation_feedback(user_id);
CREATE INDEX IF NOT EXISTS idx_cancellation_feedback_pack_id ON cancellation_feedback(pack_id);
CREATE INDEX IF NOT EXISTS idx_cancellation_feedback_reason ON cancellation_feedback(reason);

-- Politiques RLS
ALTER TABLE user_credits ENABLE ROW LEVEL SECURITY;
ALTER TABLE cancellation_feedback ENABLE ROW LEVEL SECURITY;

-- Politiques pour user_credits
DROP POLICY IF EXISTS "Users can view their own credits" ON user_credits;
CREATE POLICY "Users can view their own credits" ON user_credits
  FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Service can manage credits" ON user_credits;
CREATE POLICY "Service can manage credits" ON user_credits
  FOR ALL USING (true);

-- Politiques pour cancellation_feedback
DROP POLICY IF EXISTS "Users can insert their own feedback" ON cancellation_feedback;
CREATE POLICY "Users can insert their own feedback" ON cancellation_feedback
  FOR INSERT WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can view their own feedback" ON cancellation_feedback;
CREATE POLICY "Users can view their own feedback" ON cancellation_feedback
  FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Service can manage feedback" ON cancellation_feedback;
CREATE POLICY "Service can manage feedback" ON cancellation_feedback
  FOR ALL USING (true);
`;

async function deploySubscriptionSystem() {
  console.log('\nüöÄ === D√âPLOIEMENT DU SYST√àME D\'ABONNEMENTS ===\n');

  try {
    // 1. V√©rifier que Supabase CLI est disponible
    console.log('üîç 1. V√©rification de Supabase CLI...');
    let supabaseCmd = 'supabase';
    try {
      execSync('supabase --version', { stdio: 'pipe' });
      console.log('‚úÖ Supabase CLI d√©tect√© (global)');
    } catch (error) {
      try {
        execSync('npx supabase --version', { stdio: 'pipe' });
        supabaseCmd = 'npx supabase';
        console.log('‚úÖ Supabase CLI d√©tect√© (via npx)');
      } catch (npxError) {
        console.log('‚ö†Ô∏è Supabase CLI non trouv√©, installation locale...');
        try {
          execSync('npm install supabase --save-dev', { stdio: 'inherit' });
          supabaseCmd = 'npx supabase';
          console.log('‚úÖ Supabase CLI install√© localement');
        } catch (installError) {
          throw new Error('Impossible d\'installer Supabase CLI. Installez-le manuellement.');
        }
      }
    }

    // 2. V√©rifier que nous sommes dans le bon r√©pertoire
    console.log('\nüìÅ 2. V√©rification du r√©pertoire...');
    if (!fs.existsSync('./supabase')) {
      throw new Error('R√©pertoire supabase non trouv√©. Ex√©cutez ce script depuis la racine du projet.');
    }
    console.log('‚úÖ R√©pertoire supabase trouv√©');

    // 3. V√©rifier les nouvelles fonctions
    console.log('\nüîß 3. V√©rification des nouvelles fonctions...');
    const missingFunctions = [];
    NEW_FUNCTIONS.forEach(funcName => {
      const funcPath = path.join(FUNCTIONS_DIR, funcName, 'index.ts');
      if (fs.existsSync(funcPath)) {
        console.log(`‚úÖ ${funcName} trouv√©e`);
      } else {
        console.log(`‚ùå ${funcName} manquante`);
        missingFunctions.push(funcName);
      }
    });

    if (missingFunctions.length > 0) {
      throw new Error(`Fonctions manquantes: ${missingFunctions.join(', ')}`);
    }

    // 4. Cr√©er le fichier SQL pour les tables
    console.log('\nüìã 4. Cr√©ation du fichier SQL pour les tables...');
    const sqlFilePath = './supabase/migrations/create_subscription_tables.sql';
    
    // Cr√©er le r√©pertoire migrations s'il n'existe pas
    const migrationsDir = './supabase/migrations';
    if (!fs.existsSync(migrationsDir)) {
      fs.mkdirSync(migrationsDir, { recursive: true });
      console.log('‚úÖ R√©pertoire migrations cr√©√©');
    }

    // √âcrire le fichier SQL
    fs.writeFileSync(sqlFilePath, REQUIRED_TABLES_SQL);
    console.log(`‚úÖ Fichier SQL cr√©√©: ${sqlFilePath}`);

    // 5. D√©ployer les fonctions
    console.log('\nüöÄ 5. D√©ploiement des fonctions Supabase...');
    try {
      console.log('   D√©ploiement en cours...');
      execSync(`${supabaseCmd} functions deploy`, { stdio: 'inherit' });
      console.log('‚úÖ Fonctions d√©ploy√©es avec succ√®s');
    } catch (error) {
      console.log('‚ö†Ô∏è Erreur lors du d√©ploiement des fonctions:');
      console.log(`   Vous pouvez d√©ployer manuellement avec: ${supabaseCmd} functions deploy`);
    }

    // 6. Appliquer les migrations
    console.log('\nüìä 6. Application des migrations de base de donn√©es...');
    try {
      console.log('   Application des migrations...');
      execSync(`${supabaseCmd} db push`, { stdio: 'inherit' });
      console.log('‚úÖ Migrations appliqu√©es avec succ√®s');
    } catch (error) {
      console.log('‚ö†Ô∏è Erreur lors de l\'application des migrations:');
      console.log(`   Vous pouvez appliquer manuellement avec: ${supabaseCmd} db push`);
      console.log('   Ou ex√©cuter le SQL directement dans le dashboard Supabase');
    }

    // 7. V√©rifier les variables d'environnement
    console.log('\nüîê 7. V√©rification des variables d\'environnement...');
    const requiredEnvVars = [
      'SUPABASE_URL',
      'SUPABASE_ANON_KEY',
      'STRIPE_SECRET_KEY',
      'STRIPE_WEBHOOK_SECRET',
      'FRONTEND_URL'
    ];

    const missingEnvVars = [];
    requiredEnvVars.forEach(envVar => {
      if (process.env[envVar]) {
        console.log(`‚úÖ ${envVar} configur√©e`);
      } else {
        console.log(`‚ùå ${envVar} manquante`);
        missingEnvVars.push(envVar);
      }
    });

    if (missingEnvVars.length > 0) {
      console.log(`\n‚ö†Ô∏è Variables d'environnement manquantes: ${missingEnvVars.join(', ')}`);
      console.log('   Configurez-les dans votre fichier .env ou dans Supabase Dashboard');
    }

    // 8. R√©sum√© du d√©ploiement
    console.log('\n‚úÖ === D√âPLOIEMENT TERMIN√â ===\n');
    
    console.log('üìã NOUVELLES FONCTIONS D√âPLOY√âES:');
    NEW_FUNCTIONS.forEach(func => {
      console.log(`   - ${func}`);
    });

    console.log('\nüìä NOUVELLES TABLES CR√â√âES:');
    console.log('   - user_credits (gestion des cr√©dits)');
    console.log('   - cancellation_feedback (retours d\'annulation)');

    console.log('\nüéØ PROCHAINES √âTAPES:');
    console.log('1. Tester les nouvelles fonctions avec: node test-subscription-system.cjs');
    console.log('2. Mettre √† jour l\'interface utilisateur pour utiliser smart-pack-change');
    console.log('3. Configurer les webhooks Stripe si n√©cessaire');
    console.log('4. Former l\'√©quipe sur le nouveau syst√®me');
    console.log('5. Surveiller les logs lors des premiers changements de pack');

    console.log('\nüîó ENDPOINTS DISPONIBLES:');
    console.log(`   - POST /functions/v1/smart-pack-change`);
    console.log(`   - POST /functions/v1/calculate-pack-difference`);
    console.log(`   - POST /functions/v1/process-immediate-change`);
    console.log(`   - POST /functions/v1/handle-subscription-change`);
    console.log(`   - POST /functions/v1/cancel-subscription`);

  } catch (error) {
    console.error('\n‚ùå ERREUR DE D√âPLOIEMENT:', error.message);
    console.log('\nüîß D√âPLOIEMENT MANUEL:');
    console.log('1. D√©ployez les fonctions: supabase functions deploy');
    console.log('2. Appliquez les migrations: supabase db push');
    console.log('3. Ou ex√©cutez le SQL manuellement dans Supabase Dashboard');
    process.exit(1);
  }
}

// Fonction pour g√©n√©rer un guide de migration
function generateMigrationGuide() {
  console.log('\nüìñ === GUIDE DE MIGRATION ===\n');
  
  console.log('üîÑ REMPLACEMENT DES ANCIENNES FONCTIONS:');
  console.log('\n1. Remplacer create-checkout-session par smart-pack-change:');
  console.log('   AVANT: POST /functions/v1/create-checkout-session');
  console.log('   APR√àS: POST /functions/v1/smart-pack-change');
  
  console.log('\n2. Remplacer change-pack-with-payment par smart-pack-change:');
  console.log('   AVANT: POST /functions/v1/change-pack-with-payment');
  console.log('   APR√àS: POST /functions/v1/smart-pack-change');
  
  console.log('\nüìù CHANGEMENTS D\'API:');
  console.log('\nANCIEN FORMAT:');
  console.log('{ "packId": "uuid" }');
  
  console.log('\nNOUVEAU FORMAT (identique):');
  console.log('{ "packId": "uuid" }');
  
  console.log('\nNOUVELLE R√âPONSE:');
  console.log(`{
  "success": true,
  "message": "Pack chang√© avec succ√®s",
  "changeType": "upgrade|downgrade|same_price|first_pack",
  "requiresPayment": false,
  "checkoutUrl": "https://checkout.stripe.com/...", // Si paiement requis
  "effectiveImmediately": true,
  "creditApplied": 1500 // Si cr√©dit accord√©
}`);

  console.log('\nüé® CHANGEMENTS UI RECOMMAND√âS:');
  console.log('1. Afficher le type de changement (upgrade/downgrade)');
  console.log('2. Montrer les √©conomies pour les downgrades');
  console.log('3. Expliquer la proration pour les upgrades');
  console.log('4. Ajouter un bouton d\'annulation d\'abonnement');
  console.log('5. Afficher les cr√©dits utilisateur disponibles');
}

// Fonction pour tester la connectivit√©
async function testConnectivity() {
  console.log('\nüîó Test de connectivit√©...');
  
  try {
    const { createClient } = require('@supabase/supabase-js');
    const supabase = createClient(
      process.env.SUPABASE_URL || '',
      process.env.SUPABASE_ANON_KEY || ''
    );
    
    const { data, error } = await supabase.from('packs').select('count').limit(1);
    
    if (error) {
      console.log('‚ùå Erreur de connexion Supabase:', error.message);
    } else {
      console.log('‚úÖ Connexion Supabase OK');
    }
  } catch (error) {
    console.log('‚ùå Erreur de test:', error.message);
  }
}

// Ex√©cution du script
if (require.main === module) {
  const args = process.argv.slice(2);
  
  if (args.includes('--guide')) {
    generateMigrationGuide();
  } else if (args.includes('--test')) {
    testConnectivity();
  } else {
    deploySubscriptionSystem()
      .then(() => {
        console.log('\nüéâ D√©ploiement termin√© avec succ√®s!');
        console.log('\nUtilisez --guide pour voir le guide de migration');
        console.log('Utilisez --test pour tester la connectivit√©');
      })
      .catch(error => {
        console.error('üí• Erreur fatale:', error);
        process.exit(1);
      });
  }
}

module.exports = {
  deploySubscriptionSystem,
  generateMigrationGuide,
  testConnectivity
};